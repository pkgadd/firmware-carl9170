From 1b6a3060adfff3171b8e605c7fea82f04cf7c768 Mon Sep 17 00:00:00 2001
From: Christian Lamparter <chunkeey@googlemail.com>
Date: Fri, 1 Jul 2011 23:31:26 +0200
Subject: [PATCH 03/10] carl9170 firmware: improve site survey data

Luis' automatic channel selection needs tx_time in
order to work. Trouble is, the documentation does
not mention such a counter, so a software solution
is needed.

Signed-off-by: Christian Lamparter <chunkeey@googlemail.com>
---
 carlfw/include/carl9170.h |    1 +
 carlfw/include/rf.h       |    2 --
 carlfw/src/cmd.c          |    2 +-
 carlfw/src/main.c         |   27 ++++++++++++++++++++++-----
 carlfw/src/rf.c           |   37 ++-----------------------------------
 include/shared/fwcmd.h    |    5 +++--
 include/shared/hw.h       |    6 ++++++
 7 files changed, 35 insertions(+), 45 deletions(-)

--- a/carlfw/include/carl9170.h
+++ b/carlfw/include/carl9170.h
@@ -204,6 +204,7 @@ struct firmware_context_struct {
 
 	unsigned int tally_clock;
 	struct carl9170_tally_rsp tally;
+	unsigned int tx_time;
 
 #ifdef CONFIG_CARL9170FW_GPIO_INTERRUPT
 	struct carl9170_gpio cached_gpio_state;
--- a/carlfw/include/rf.h
+++ b/carlfw/include/rf.h
@@ -28,8 +28,6 @@
 
 #include "config.h"
 
-void tally_update(void);
-
 #ifdef CONFIG_CARL9170FW_RADIO_FUNCTIONS
 void rf_notify_set_channel(void);
 void rf_cmd(const struct carl9170_cmd *cmd, struct carl9170_rsp *resp);
--- a/carlfw/src/cmd.c
+++ b/carlfw/src/cmd.c
@@ -95,7 +95,7 @@ void handle_cmd(struct carl9170_rsp *res
 	case CARL9170_CMD_TALLY:
 		resp->hdr.len = sizeof(struct carl9170_tally_rsp);
 		memcpy(&resp->tally, &fw.tally, sizeof(struct carl9170_tally_rsp));
-		tally_update();
+		resp->tally.tick = fw.ticks_per_usec;
 		memset(&fw.tally, 0, sizeof(struct carl9170_tally_rsp));
 		break;
 
--- a/carlfw/src/main.c
+++ b/carlfw/src/main.c
@@ -134,10 +134,6 @@ static void timer0_isr(void)
 	gpio_timer();
 #endif /* CONFIG_CARL9170FW_GPIO_INTERRUPT */
 
-#ifdef CONFIG_CARL9170FW_RADIO_FUNCTIONS
-	tally_update();
-#endif /* CONFIG_CARL9170FW_RADIO_FUNCTIONS */
-
 #ifdef CONFIG_CARL9170FW_DEBUG_LED_HEARTBEAT
 	set(AR9170_GPIO_REG_PORT_DATA, get(AR9170_GPIO_REG_PORT_DATA) ^ 1);
 #endif /* CONFIG_CARL9170FW_DEBUG_LED_HEARTBEAT */
@@ -168,6 +164,27 @@ static void handle_timer(void)
 #undef HANDLER
 }
 
+static void tally_update(void)
+{
+	unsigned int boff, time, delta;
+
+	time = get_clock_counter();
+	if (fw.phy.state == CARL9170_PHY_ON) {
+		delta = (time - fw.tally_clock);
+
+		fw.tally.active += delta;
+
+		boff = get(AR9170_MAC_REG_BACKOFF_STATUS);
+		if (boff & AR9170_MAC_BACKOFF_TX_PE)
+			fw.tally.tx_time += delta;
+		if (boff & AR9170_MAC_BACKOFF_CCA)
+			fw.tally.cca += delta;
+	}
+
+	fw.tally_clock = time;
+	fw.counter++;
+}
+
 static void __noreturn main_loop(void)
 {
 	/* main loop */
@@ -186,7 +203,7 @@ static void __noreturn main_loop(void)
 
 		handle_timer();
 
-		fw.counter++;
+		tally_update();
 	}
 }
 
--- a/carlfw/src/rf.c
+++ b/carlfw/src/rf.c
@@ -29,32 +29,6 @@
 #include "rf.h"
 #include "shared/phy.h"
 
-void tally_update(void)
-{
-	unsigned int time;
-
-#ifdef CONFIG_CARL9170FW_RADIO_FUNCTIONS
-	unsigned int main_not_free, ext_not_free;
-
-	main_not_free = get(AR9170_MAC_REG_CHANNEL_BUSY);
-	ext_not_free = get(AR9170_MAC_REG_EXT_BUSY);
-	time = get_clock_counter();
-
-	if (fw.phy.state == CARL9170_PHY_ON) {
-		unsigned int us_delta = (time - fw.tally_clock) / max(fw.ticks_per_usec, 40u);
-
-		fw.tally.active += us_delta;
-		fw.tally.main_free += main_not_free;
-		fw.tally.ext_free += ext_not_free;
-	}
-#else
-	time = get_clock_counter();
-
-#endif /* CONFIG_CARL9170FW_RADIO_FUNCTIONS */
-
-	fw.tally_clock = time;
-}
-
 #ifdef CONFIG_CARL9170FW_RADIO_FUNCTIONS
 static void set_channel_end(void)
 {
@@ -64,16 +38,11 @@ static void set_channel_end(void)
 	andl(AR9170_MAC_REG_QOS_PRIORITY_VIRTUAL_CCA,
 	     ~AR9170_MAC_VIRTUAL_CCA_ALL);
 
-	/* clear statistics */
-	tally_update();
-
 	fw.phy.state = CARL9170_PHY_ON;
 }
 
 void rf_notify_set_channel(void)
 {
-	tally_update();
-
 	/* Manipulate CCA threshold to stop transmission */
 	set(AR9170_PHY_REG_CCA_THRESHOLD, 0x300);
 	/* Enable Virtual CCA */
@@ -82,8 +51,8 @@ void rf_notify_set_channel(void)
 
 	/* reset CCA stats */
 	fw.tally.active = 0;
-	fw.tally.main_free = 0;
-	fw.tally.ext_free = 0;
+	fw.tally.cca = 0;
+	fw.tally.tx_time = 0;
 	fw.phy.state = CARL9170_PHY_OFF;
 }
 
@@ -276,7 +245,6 @@ void rf_psm(void)
 		/* Synthesizer off + RX off */
 		bank3 = 0x00400018;
 
-		tally_update();
 		fw.phy.state = CARL9170_PHY_OFF;
 	} else {
 		/* advance to the next PSM step */
@@ -294,7 +262,6 @@ void rf_psm(void)
 			/* Synthesizer on + RX on */
 			bank3 = 0x01420098;
 
-			tally_update();
 			fw.phy.state = CARL9170_PHY_ON;
 		} else {
 			return ;
--- a/include/shared/fwcmd.h
+++ b/include/shared/fwcmd.h
@@ -289,10 +289,11 @@ struct carl9170_tsf_rsp {
 
 struct carl9170_tally_rsp {
 	__le32 active;
-	__le32 main_free;
-	__le32 ext_free;
+	__le32 cca;
+	__le32 tx_time;
 	__le32 rx_total;
 	__le32 rx_overrun;
+	__le32 tick;
 } __packed;
 
 struct carl9170_rsp {
--- a/include/shared/hw.h
+++ b/include/shared/hw.h
@@ -222,6 +222,12 @@
 #define AR9170_MAC_REG_TX_BLOCKACKS		(AR9170_MAC_REG_BASE + 0x6c0)
 #define AR9170_MAC_REG_NAV_COUNT		(AR9170_MAC_REG_BASE + 0x6c4)
 #define AR9170_MAC_REG_BACKOFF_STATUS		(AR9170_MAC_REG_BASE + 0x6c8)
+#define		AR9170_MAC_BACKOFF_CCA			BIT(24)
+#define		AR9170_MAC_BACKOFF_TX_PEX		BIT(25)
+#define		AR9170_MAC_BACKOFF_RX_PE		BIT(26)
+#define		AR9170_MAC_BACKOFF_MD_READY		BIT(27)
+#define		AR9170_MAC_BACKOFF_TX_PE		BIT(28)
+
 #define	AR9170_MAC_REG_TX_RETRY			(AR9170_MAC_REG_BASE + 0x6cc)
 
 #define AR9170_MAC_REG_TX_COMPLETE		(AR9170_MAC_REG_BASE + 0x6d4)
